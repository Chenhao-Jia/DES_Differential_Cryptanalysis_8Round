import DES_8_Round as c
import random
from textwrap import wrap

S=[[['000001', '011100', '111011', '111110'], ['010111', '011110', '100101', '101000'], ['000010', '000101', '100111', '101110'], ['001000', '001101', '100101', '100110'], ['010011', '011010', '110101', '111100'], ['010000', '011001', '110010', '111011'], ['000011', '001010', '110101', '111000'], ['011001', '011010', '110000', '110111']], [['000001', '011100', '111011', '111110'], ['010011', '011010', '100000', '111001'], ['000010', '000101', '100111', '101110'], ['001000', '001101', '100101', '100110'], ['010011', '011010', '110101', '111100'], ['010000', '011001', '110010', '111011'], ['000000', '001001', '100010', '101011'], ['011001', '011010', '110000', '110111']]]

#PIOX

#Possible Input Output Xors
#Convention is that after expansion is input_num before is input_num_before_exp
#task is to find F_prime , where we know T_l_prme and e_prime and h_prime is right of cipher
# 00540000 = 00000000010101000000000000000000
# c.expand()=000000000000001010101000000000000000000000000000
# 00100000 = 00000000000100000000000000000000


# 04000000 = 00000100000000000000000000000000
# c.expand()=000000001000000000000000000000000000000000000000
# 0A000000 = 00001010000000000000000000000000

def inverse_table(table,size):
	new=list()
	for x in range(size):
		if((x+1) in table) :
			num=table.index(x+1)+1
			new.append(num)
		else :
			new.append(x)
	return new

def add_zero(x,num):
    h=len(x)
    if h<num:
        for i in range(num-h):
            x="0"+x
    return x

def gen_string(n):
	left=bin(random.randint(0,2**n-1))[2:]
	left=add_zero(left,n)
	return left

def xor(string,key,num):
    answer=""
    for x in range(num):
        if string[x]==key[x] :
            answer+="0"
        else :
            answer+="1"
    return answer

def opp_per_func(s_output):
  Inv_Per_Table=[9,17,23,31,13,28,2,18,24,16,30,6,26,20,10,1,8,14,25,3,4,29,11,19,32,12,22,7,5,27,15,21]
  s_final = ""
  for x in Inv_Per_Table:
    s_final += s_output[x-1]
  return s_final

def key_42():
	key_42_bits=""
	for p in range(1,8):
		keys=[[],[],[],[],[],[],[]]
		final=set()
		for i in range(7):
			P1=gen_string(64)
			P2=xor(P1,char,64)

			P1=add_zero(hex(int(P1,2))[2:],16)
			cipher_text1_tmp=add_zero(bin(int(c.enc(P1),16))[2:],64)

			P2=add_zero(hex(int(P2,2))[2:],16)

			cipher_text2_tmp=add_zero(bin(int(c.enc(P2),16))[2:],64)

			cipher_text1=""
			cipher_text2=""

			for m in IP:
				cipher_text1+=cipher_text1_tmp[m-1]

			for m in IP:
				cipher_text2+=cipher_text2_tmp[m-1]

			d=xor(cipher_text1,cipher_text2,64)[32:]
			left=xor(cipher_text1,cipher_text2,64)[:32]

			B=c.per_func('11110000000000000000000000000000')

			D=xor(B,left,32)

			D_before=opp_per_func(D)

			So=wrap(D_before,4)

			input_last_round1=c.expand(cipher_text1[32:])
			input_last_round2=c.expand(cipher_text2[32:])

			Se=wrap(input_last_round1,6)
			Se_star=wrap(input_last_round2,6)

			for x in range(2**6):
				key=add_zero(bin(x)[2:],6)
				y=xor(Se[p],key,6)
				z=xor(Se_star[p],key,6)
				y1=c.s_box(y,p+1)
				y2=c.s_box(z,p+1)
				if xor(y1,y2,4) == So[p] :
					keys[i].append(key)

		for x in range(1,5):
			keys[x]=set(keys[x]).intersection(set(keys[x-1]))

		key_42_bits+=list(keys[4])[0]

	return("xxxxxx"+key_42_bits)

possible_xors_sboxes=[]

for a in range(8):
	possible_xors_sboxes.append([
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],
])
#def possible_inputs_6():
for s in range(8) :
	for x in range(2**6):
		s_input=add_zero(bin(x)[2:],6)
		for y in range(2**6):
			s_input_star=add_zero(bin(y)[2:],6)
			input_xor=xor(s_input_star,s_input,6)
			col=int(input_xor,2)
			output_xor=xor(c.s_box(s_input,s+1),c.s_box(s_input_star,s+1),4)
			row=int(output_xor,2)
			#print(index)
			possible_xors_sboxes[s][row][col].append(s_input)

for u in range(8):
	possible_xors_sboxes[u]=list(map(list, zip(*possible_xors_sboxes[u])))

arr_counters_18=[]
for x in range(2**18):
	arr_counters_18.append(0)

for top in range(5000):
	char64=add_zero(bin(int("405C000004000000",16))[2:],64)

	input5_xor_32=c.expand(char64[32:])

	P1=gen_string(64)
	P2=xor(P1,char64,64)
	P1=add_zero(hex(int(P1,2))[2:],16)
	cipher_text1=add_zero(bin(int(c.enc(P1),16))[2:],64)

	P2=add_zero(hex(int(P2,2))[2:],16)

	cipher_text2=add_zero(bin(int(c.enc(P2),16))[2:],64)

	cipher_xor=xor(cipher_text1,cipher_text2,64)

	h_prime=cipher_xor[32:]
	H_prime=cipher_xor[:32]
	S_h=cipher_text1[32:]
	S_h_input=c.expand(S_h)

	after_exp1=c.expand(cipher_text1[32:])
	after_exp2=c.expand(cipher_text2[32:])

	S_prime_e=xor(after_exp1,after_exp2,48)
	S_prime_o=opp_per_func(H_prime)

	S_h_input_list=wrap(S_h_input,6)
	S_prime_e_list=wrap(S_prime_e,6)
	S_prime_o_list=wrap(S_prime_o,4)

	Boxes=[1,5,6,7]
	six_bit_key=[[],[],[]]
	i = -1

	if c.s_box(S_prime_e_list[1],2) == S_prime_o_list[1] and c.s_box(S_prime_e_list[5],6) == S_prime_o_list[5] and c.s_box(S_prime_e_list[6],7) == S_prime_o_list[6] and c.s_box(S_prime_e_list[7],8) == S_prime_o_list[7] :
		for x in Boxes :
				if x == 1:
					continue
				row = S_prime_e_list[x]
				row=int(row,2)

				col=S_prime_o_list[x]
				col=int(col,2)
				i = i+1

				for poss in possible_xors_sboxes[x][row][col]:
					six_bit_key[i].append(xor(S_h_input_list[x],poss,6))

		for first in six_bit_key[0]:
			for second in six_bit_key[1]:
				for third in six_bit_key[2]:
					index=int(first+second+third,2)
					arr_counters_18[index]+=1

	#print(six_bit_key)

#print(arr_counters_18)
print(add_zero(bin(arr_counters_18.index(max(arr_counters_18)))[2:],18))
print(max(arr_counters_18))
arr_counters_18.remove(max(arr_counters_18))
print(max(arr_counters_18))














































# # Second round with low probability
# #In S[][] first is the round, second is the sbox
# expanded_second_round_input_xor="000000000000001010101000000000000000000000000000"
# reverse_per_second_round_output_xor="00000000000000000000000001000000"
# list_expanded_second_round_input_xor=wrap(expanded_second_round_input_xor,6)
# list_reverse_per_second_round_output_xor=wrap(reverse_per_second_round_output_xor,4)

# for x in range(8):
# 	for i in range(2**6):
# 		input_xor=add_zero(bin(i)[2:],6)
# 		output_xor=list_reverse_per_second_round_output_xor[x]
# 		if c.s_box(input_xor,x+1) == output_xor :
# 			S[1][x].append(input_xor)



# # First round with 1/4 probability
# #In S[][] first is the round, second is the sbox

# expanded_first_round_input_xor="000000001000000000000000000000000000000000000000"
# reverse_per_first_round_output_xor="00001010000000000000000000000000"
# list_expanded_first_round_input_xor=wrap(expanded_first_round_input_xor,6)
# list_reverse_per_first_round_output_xor=wrap(reverse_per_first_round_output_xor,4)

# for x in range(8):
# 	for i in range(2**6):
# 		input_xor=add_zero(bin(i)[2:],6)
# 		output_xor=list_reverse_per_first_round_output_xor[x]
# 		if c.s_box(input_xor,x+1) == output_xor :
# 			S[0][x].append(input_xor)
